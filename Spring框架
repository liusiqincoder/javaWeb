Spring采取了以下几种技术：
   1.基于POJO的编程（简单的javaBean）Spring不要求实现Spring规范的接口或继承Spring规范的类
   2.通过依赖注入组合类
        程序运行期间由容器动态地为目标类的实例构建完成依赖关系的手段（通过属性设置或构造函数引入依赖对象达到松耦合）
   3.面向切面编程AOP
        允许开发者把遍布应用各处的功能分离出来形成可重用的组件
        （日志记录，性能统计，安全控制，事务处理，异常处理）
   4.利用模板消除重复代码
   5.Bean容器
      将管理的对象称为Bean，Spring是基于容器的框架

Spring是轻量级的控制反转（IOC）和面向切面的框架（AOP）
    适用范围：1.构建企业应用（SpringMvc+Spring+hibernate/ibatis）
             2.单独使用bean容器
             3.其它应用（如：消息的支持）
             4.在互联网的应用
             
    Bean配置项：Id   Class   Scope    Constructor arguments     Properties    Autowiring mode     Initialization/destruction mode
        初始化，静态初始化和实例初始化
        
        ApplicationContext apc=new ClassPathXmlApplicationContext("beans.xml");
        /*静态化工厂
        car c= (car) apc.getBean("aCar");
        System.out.println(c.getName());
        
        xml配置
        <!--静态工厂方法创建Bean-->
    <bean id="aCar" class="创建工厂.carFactory" factory-method="getCar">
        <constructor-arg value="宝马"/>
    </bean>

    <!--实例化工厂创建Bean-->
    <!--首先，创建实例工厂对象-->
    <bean id="instanceFactory" class="创建工厂.instanceFactory"></bean>
    <!--然后就可以使用instanceFactory创建car对象-->
    <bean id="instanceCar" factory-bean="instanceFactory" factory-method="getCar" scope="prototype">
        <constructor-arg value="奔驰"/>
    </bean>
    
        作用域：singleton单例，指一个Bean容器中只存在一份
               prototype每次请求创建新的实例，destory不生效
               request 每次http请求创建一个实例且仅在当前request生效
               session同上
               global session基于portlet的web中有效，在web中和session差不多
       将Bean创建后，有Spring的ioc容器管理（充当管理者的一般是BeanFactory或ApplicationContext）
       bean的生命周期 :
              Bean的建立-->Setter注入-->实行bean实现的接口的方法（BeanNameAware的setBeanName()，BeanFactoryAware的setBeanFactory()
               BeanPostProcessors的processBeforeInitialization()，InitializingBean的afterPropertiesSet()）-->初始化-->
               BeanPostProcessors的processAfterInitialization()-->容器关闭-->销毁
               
               Bean的创建  
                   在xml文件中指定init-method，格式如下
                   <bean id="instanceCar" factory-bean="instanceFactory" init-method="methodName"
                     factory-method="getCar" scope="singleton">
                     <constructor-arg value="奔驰"/>
                   </bean>
                   销毁
                   <bean id="instanceCar" factory-bean="instanceFactory" 
                      destroy-method="methodName" factory-method="getCar" scope="singleton">
                    <constructor-arg value="奔驰"/>
                   </bean>
                   这里的scope要为singleton，而且容器要关闭才能自动进行销毁
              后处理bean   在容器内的bean初始化前后执行before和after方法
                   首先的有一个类 implements BeanPostProcessor，实现before和after
                   然后在xml配置该类：<bean class="classPath"></bean>
              
  Spring的ioc的注解开发
       需要在xml加入约束xsi:schemaLocation=" http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd        
           http://www.springframework.org/schema/context 
           http://www.springframework.org/schema/context/spring-context.xsd"
          加入注解扫描语句<!--开启注解扫描，加上才能用ioc注解-->
          <context:component-scan base-package="ioc的注解开发"/> 
          在类上加上@Component("user")相当于创建了bean
                  @Scope控制bean的作用范围
          <context:component-scan>提供了两个子标签
              <context:include-filter>  use-dafault-filters="false"的情况下 需要扫描的文件
              <context:exclude-filter>  use-dafault-filters="true"的情况下  不需要扫描的文件
          @Resource  注解默认按名称装配。名称可以通过name属性指定，如果没有指定name属性，默认取属性的名称作为bean名称寻找依赖对象
             @Qualifier("user") 和@Autowired配合使用
          
